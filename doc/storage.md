# Блокчейн хранилище

Что это? Это смарт-контракт созданный для хранения данных. Для более удобной работы с данными и удешевления использования они хранятся в виде обычных строк, которые нужно изменять за пределами контракта. Все что он делает это сохраняет, меняет, возвращает и удаляет строк(у|и). А за то что в них находится, отвечает тот кто работает с контрактом. На данный момент, для привязки (сохранения, получения, изменения) данных какого-либо приложения к самому приложению мы используем название домена.

- [Код контракта](https://github.com/NotEternal/contracts/blob/main/contracts/Storage.sol)
- Главный задеплоиный контракт для использования находится на **Binance Smart Chain**: [Storage](https://bscscan.com/address/0xa7472f384339d37efe505a1a71619212495a973a#code=)

Можно работать с любыми библиотеками на фронте, но при этом по возможности нужно использовать единственный контракт хранилища. Этим мы достигнем простоты изменения, переноса и контроля над данными. Будет проблемой, если использовать много контрактов на разных сетях или менять что-то в нем только для себя. Главное думать о совместимости.
Если нужно что-то изменить в контракте (к примеру улучшить хранение данных или добавить функционал), тогда сначала создаем новую версию контракта, затем делаем миграцию всех приложений, которые используют старый контракт.

## Сохранение и загрузка данных в приложении

Общая схема работы:

```
      Frontend               Blockchain
┌──────────────────────┐ ┌──────────────────┐
│                      │ │                  │
│ App main interface ◄─┼─┼────────┐         │
│     │                │ │        │         │
│     │                │ │        │         │
│     │                │ │ Storage contract │
│     │                │ │        ▲         │
│     ▼                │ │        │         │
│ Admin panel ─────────┼─┼────────┘         │
│                      │ │                  │
└──────────────────────┘ └──────────────────┘
```

### Пример админ панели

> код только на [React](https://reactjs.org/). Много моментов уменьшено и упрощено.

Сделаем панель через которую можно изменить логотип приложения и работать с хранилищем.

1. Создаем функции для работы с контрактом в `utils.js`:

```js
import Web3 from "web3";
import { STORAGE_ADDRESS } from "./constants";
import { Storage } from "./contractBuilds";

const currentDomain = () => window.location.hostname || document.location.host;

const getStorage = (provider) => {
  const web3 = new Web3(provider);

  return web3.eth.Contract(Storage.abi, STORAGE_ADDRESS);
};

export const saveData = async ({ provider, owner, data }) => {
  const storage = getStorage(provider);

  return storage.methods.setKeyData(currentDomain(), {
    owner,
    info: JSON.stringify(data),
  });
};

export const fetchData = async (provider) => {
  const storage = getStorage(provider);
  const { info, owner } = await storage.methods.getData(currentDomain()).call();

  return { ...JSON.parse(info), admin: owner };
};
```

2. Компонент `AdminPanel.jsx`:

```jsx
// ...
import { saveData } from "./utils";

export default function AdminPanel() {
  const { library, account } = useActiveWeb3React();
  const [logoUrl, setLogoUrl] = useState("");
  const onLogoUrl = (event) => setLogoUrl(event.target.value);

  const saveLogo = async () => {
    await saveData({
      provider: library.provider,
      owner: account,
      data: {
        logoUrl,
      },
    });
  };

  return (
    <div>
      <input value={logoUrl} onChange={onLogoUrl} placeholder="Logo URL" />
      <button onClick={saveLogo} disabled={!logoUrl}>
        Save
      </button>
    </div>
  );
}
```

3. При клике на кнопку у нас откроется внешний кошелек где нужно подтвердить транзакцию сохранения, в которой мы сохраняем JSON строку с `logoUrl` параметром в контракт. Теперь нужно запросить данные при загрузке приложения и использовать их. В `App.jsx`:

```js
// ...
import { fetchData } from "./utils";

export default function App() {
  const { library, chainId } = useActiveWeb3React();
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetch = async () => {
      const data = await fetchData(library.provider);

      setData(data);
    };

    fetch();
  }, [chainId, library]);

  return (
    <div>
      <header>
        <img src={data.logoUrl || "default path"} />
      </header>
      {/* ... */}
    </div>
  );
}
```

## Ответы на популярные вопросы

#### Почему обязательно использовать блокчейн?

Mы работаем со смарт-контрактами, работа которых происходит в блокчейне. Приложения также построенны на блокчейне. Возможно усложнить схему и добавить еще что-либо, дополнительные сервера с логикой, увеличить расход ресурсов и времени. но зачем это нужно?

### Разница между обычной базой данных и контрактом?

В базе данных есть заранее готовый интерфейс для работы с данными. В контракте же нет готовых методов или схем для взяимодействия с данными. Нам нужно писать контракт в ручную под свои потребности. В нашем случае структура данных слишком сложна чтобы использовать встроенные в [Solidity](https://docs.soliditylang.org/) типы и способы для их зменения. Поэтому в контракте хранилища все хранится в виде строк, за изменения которых отвечает внешняя сторона.

#### Почему это лучше?

- Данные хранятся в блокчейне, что означает их распределенную структуру
- Не нужно делать свой сервер(а) с базой данных
- Их не сможет изменить или удалить кто-то посторонний
- Доступ к данным сохраняется 24/7. Сервер тоже может работать в таком режиме, но в распределенной схеме со множеством нод (компьютеров) шансы проблем уменьшаются в разы

#### Почему это хуже?

- Данные прозрачны и открыты, даже если они находятся в нечитаемом для человека виде. Поэтому хранить приватные данные нужно только зашифрованными
- Явные затраты для клиента, так-как нужно платить за изменение состояния блокчейна

#### Почему не использовать тестовый блокчейн?

Он не имеет своего значения, ценности и доверия. Есть вероятность (совсем небольшая для публичных сетей) сброса блокчейна, то есть удаление его данных. Также исходя из названия можно понять что его состояние менее стабильно чем у главной сети.

#### Почему именно этот контракт?

Потому что это лучшее что есть на данный момент. Думаю не будет проблемой начать использовать другое решение, если оно появится.

### Как хранятся данные?

Весь код отвечающий за хранение:

```js
struct Data {
    address owner;
    string info;
}

mapping(string => Data) private allData;
```

Детали:

- `struct Data`: тип описывающий данные. Включает в себя `owner` ключ содержащий адрес акаунта (может изменять данные) и `info` ключ содержащий строку с данными
- `(string => ...`: ключ в виде строки, по которому получаем доступ к данным
- `... => Data)`: значение в виде данных

### На сколько безопасно хранятся данные?

Все работает в блокчейне, что означает децентрализованную и криптографически защищенную систему. Данные хранятся распределенно на множестве компьютеров. Их возможно изменить только через указанные правила и с установленного аккаунта (адреса).

### Как использовать контракт напрямую?

Два основных метода для работы c хранилищем:

1. Сохранение данных:

```js
function setKeyData(string memory _key, Data memory _data) external;
```

Первым параметром передаем ключ в виде строки (домен приложения). Вторым обьект в виде `Data` структуры:

```js
{
    address owner;
    string info;
}
```

2. Получение данных:

```js
function getData(string memory _key) external view returns(Data memory);
```

Передаем параметр в виде строки (домен) и получаем обьект с адресом владельца и данными.

3. Удаление:

```js
function clearKeyData(string memory _key) external;
```

Дополнительные методы:

```js
// получаем все сохраненные ключи для данных
function allKeys() external view returns(string[] memory);
// получаем все сохраненные данные
function allKeysData() external view returns(Data[] memory);
// можно сохранить сразу несколько обьектов с данными
function setKeysData(KeyData[] memory _keysData) external;
// удаляем множество обьектов
function clearKeysData(string[] memory _keys) external;
```

### Как использовать контракт в приложении?

Мы можем использовать одну из библиотек для взаимодействия с EVM блокчейном:

- [Web3.js](https://web3js.readthedocs.io/)
- [Ethers](https://docs.ethers.io/)

Для использования хранилища нужно иметь:

- Одна из библиотек выше
- Адрес контракта
- ABI ([Application Binary Interface](https://docs.soliditylang.org/en/develop/abi-spec.html)): JSON интерфейс с помощью которого мы создаем экземпляр класса описывающий смарт-контракт (свойства, методы и тд.)

1. Получаем адрес контракта в блокчейне. Используем контракт с **BSС**: [Хранилище](https://bscscan.com/address/0xa7472f384339d37efe505a1a71619212495a973a)
2. Получаем сборку контракта (JSON в котором есть ABI): [Ccылка](https://raw.githubusercontent.com/noxonsu/unifactory/main/src/contracts/build/Storage.json)
3. Делаем новый экземпляр контракта из полученных данных:

```js
import web3 from "web3";
import { Storage } from "./abis";
import { STORAGE_ADDRESS } from "./constants";
// если мы хотим изменить данные, а не только запрашивать их,
// то нужно передать провайдера из внешнего кошелька
const web3 = new Web3("https://bsc-dataseed.binance.org");
const storage = new web3.eth.Contract(Storage.abi, STORAGE_ADDRESS);
```

4. Можно использовать контракт:
   > если работаем с внешним кошельком, нужно находиться на той же сети с которой был создан экземпляр контракта. В данном примере это BSC

```js
storage.methods.setKeyData("example.com", {
  owner: "0x...",
  info: JSON.stringify({
    foo: 1,
    bar: 2,
    subObj: {
      foo: 3,
    },
  }),
});

storage.methods.getData("example.com");
// ...
```

Если публичного доступа к ABI нет, но есть файлы контракта, тогда нужно сделать ABI самостоятельно. Для этого можно использовать:

- [Remix IDE](https://remix.ethereum.org/): все делается в браузере. Подходит для небольших проектов из 1 или нескольких контрактов
- [Truffle](https://trufflesuite.com/): набор инструментов для локальной разработки, деплоя и тестирования контрактов
- [Hardhat](https://hardhat.org/): более новый и продвинутый инструмент

#### Remix

1. Добавляем файлы контракта в первую вкладку:

<img src="./images/Remix-1.png" />

2. Компилируем и копируем ABI:

<img src="./images/Remix-2.png" />

3. Если нужно задеплоить, то открываем последнюю вкладку. Подключаем внешний кошелек предварительно выбрав в нем нужную сеть и деплоим:

<img src="./images/Remix-3.png" />

### Как работать с данными в приложении?

После получения данных из контракта, нужно решить, исходя из уже использующихся библиотек, фрейморков и собственного желания, каким образом сохранять и получать данные во всем приложении. Готовые примеры:

#### React context

#### Redux

#### MobX

### Нужно ли делать панель админа в том же дизайне как и главное приложение?

Главная задача сделать готовый продукт как можно быстрее. Со стороны дизайна мы можем сократить время не теряя функционал. Решение делать дизайн админки схожим с основным приложением нужно принимать перед началом разработки учитывая эти моменты:

- требуемое время: eсли на это потребуется несколько лет, то не нужно пытаться делать одинаковый внешний вид
- используемые инструменты: если в приложении уже есть готовая дизайн система, возможно будет быстрее использовать её
- собственные желания: хочется сделать качественно, доступно и красиво. Стоит думать об этом в конце или стараться совместить свои желания с предыдущими пунктами )

### Можно ли сделать одну админ панель и использовать во всех приложениях?

Почему не сделать готовый вариант, такой как [Bootstrap dashboard](https://themes.getbootstrap.com/product/hyper-responsive-admin-dashboard-template/)?

Плюсы:

- Сделать основную часть один раз и переиспользовать
- Изменения для разных продуктов нужно делать только в одном месте

Минусы:

- Сложно интегрировать в приложения (пока не нашли способ. Возможно single-spa?)
- Нет разделения на разные приложения и все настройки в одном месте (делать разделение внутри приложения?)
- Забыть о совпадении в дизайне панели и приложения (если не делать несколько тем)
