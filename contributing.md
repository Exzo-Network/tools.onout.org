# Как разрабатывать продукты 
https://github.com/noxonsu/tools.onout.org/blob/main/contributing.md - наш главный файл где мы систематизируем то как мы делаем продукты, цель файла стандартизировать и ускорить выпуск продуктов. необходимо, что бы мы все одинаково понимали все части этого файла (хотя бы те, что касаются разработки) поэтому предлагаю изменения вносить с ревью

Для наполнения каталога продуктов мы привлекаем разработчиков. Мы заплатим за работу и/или поделимся долей от продаж. В данынй момент возможны следующие сценарии оплаты. 
- фиксированная оплата
- зп (почасовая оплата)
- процент от продаж (распределение через токены)
- комбинирование этих типов

# Как начать?
Мы не пилим с нуля, так же не пилим без существующего клиента (agile),  клиенту нужно предложить продукт и попросить финансировать разработку, поэтому все начинается с продажи идеи. 

форк - это буквально легальная копия (лицензии это позволяют) существующего опенсорс продукта, мы делаем к нему админку. 
клиент - тот кто у нас покупает, платит нам деньги
юзер - клиент нашего клиента, т.е. конечный пользователь продукта

# шаг 1 идея 
Нужно найти в интернете рабочий продукт и предложить добавить его в наш каталог, например "сделать uniswap". Где исктаь идеи? Например посмотреть топовые апки https://etherscan.io/gastracker . так же идеи могут приходить от клиентов. идею нужно добавить в папку ideas в виде файла который включает:

1. ссылку на оригинал
2. ссылку на гитхаб (должна быть MIT или GPL лицензия)
3. почему именно этот проект, а не аналоги (почему он лучший? ссылки на comparsion исследования)
4. как админ зарабатывает (где комиссия?). ключевой пункт, какие бенифиты будут у наших клиентов 
5. перечислить user can (напр. обменивает токены, создает пулы ликвидности, зарабатывает с ликвидности)
6. перечислить admin can, что будет в админке (напр. менять цвета, логотип, спсиок токенов для обмена, комиссию)
7. (не обязательно) estimate time с комментарием. если уже был ресерч сложности, описать какие могут быть сложности 
8. (не обязательно) примерный plan . 

# шаг 2 получение интереса от клиентов 
1. добавляем к идее форму запроса по типу https://docs.google.com/forms/d/e/1FAIpQLSeBZnkoAMc1hJzs6VQmviPmoVi6mA3sCYpBJ3DtEMdJF9p8lw/viewform 
2. предлагаем идею в других наших каналах и личке
3. когда получен инетрес, т.е. есть заявки и кто то реально готов заплатить 
4. просим кредит и предоплаты (примеры позже добавлю)

# шаг 3 разработка 

> Описываются общие моменты с примерами из Uniswap форка https://github.com/noxonsu/unifactory. Предложения по улучшению описанного процесса приветствуются.

## 0. форкаем исходники оригинала. 
## 0.1 Переименовываем репозиторий.
Название не так важно и должно отображать суть продукта. Делать его очень просто: выбираем одну основную функцию или действие, которое пользователь совершает в продукте, и вставляем [сюда](https://namelix.com). Понравившийся результат берем за основу. 
## 0.2 удалить название из title
1. Разбираемся в структуре проекта. Как работает, что используется, что можно автоматизировать и возможно ли использовать только блокчейн. Желательно делать минимум изменений в оригинале (особенно в контрактах), т.к. возможно понадобится аудит, а они очень дорогие (нужно платить за строки кода). Поэтому, чем меньше изменений в оригинале, тем лучше. Нужно проверять изменения для избегания проблем и запоминать их для быстрого устранения ошибок.

Обобщенно говоря в приложении есть независимые, зависимые (т.е. те которые зависят от того, что введет будущий админ) и уникальные части:
- независимые. Мы можем не менять, то что независимо. К примеру раскладка и положение меню.
- зависимые. Части кода, которые зависят от статичных данных или констант. Обьем и кол-во таких частей нужно сделать минимальным для простоты изменений. К примеру вместо использования статичных данных от сети (**chain id** или **RPC**), заменить их на динамические значения от подключаемого внешнего кошелька.
- уникальные. В этих частях нам необходимо автоматизировать изменения, а сам обьем и кол-во таких частей сделать минимальным. То есть чтобы клиент/админ мог изменять все сам через панель и не лазить в исходники, а нам не пришлось добавлять/менять большое кол-во кода для каждого нового требования. К примеру заменить все ссылки на логотип переменной, которую админ будет изменять в панели.

2. для начала нужно сократить кол-во зависимостей (в `package.json`). В примере с Uniswap V2 из зависимого у нас есть множество файлов с импортами `@uniswap/sdk` пакета или констант с адресами и номерами сетей. Сам `@uniswap/sdk` уникален, так как в нем так же есть данные для конкретного блокчейна.
> одно из простых решений - менять уникальные данные. В примере с `@uniswap/sdk` мы можем скопировать готовый пакет из `node_modules` куда-нибудь в проект. Поправить нужные нам данные и подменять исходный пакет после каждой установки зависимостей через npm скрипт: 
```
"postinstall": "rm -rf ./node_modules/@uniswap/sdk; cp -r ./forks/@uniswap/sdk ./node_modules/@uniswap/sdk"
```
> но это не надежно и сторонняя зависимость, которую придется поддерживать все равно с нами

Мы можем сделать свой пакет и использовать его, если логика слишком сложная. Но в этом примере пакет не слишком большой и мы напрямую добавим его в проект, так как есть одинаковые зависимости в пакете и интерфейсе ([посмотрев на структуру можно видеть что **sdk** среди остальных дерикторий](https://github.com/noxonsu/unifactory/tree/main/src)). Меняем импорты этого пакета по всему проекту. Теперь мы можем использовать один файл для хранения частоиспользуемых переменных из интерфейса и **sdk** в одно место. В нашем случае это JSON файл в котором будут все нужные данные для работы приложения: [JSON config](https://github.com/noxonsu/unifactory/blob/b4677bf018d3c9c33348e95ef0d8285028f3072a/src/networks.json). Изменяем все места для использования данных из этого файла. Мы пропустили описание всех данных, но план действий для них примерно тот же.

> при описанных выше изменениях пришлось изменять большое кол-во жестких параметров на переменные (использование `ETHER.symbol` из `sdk/` меняем на `networks[chainId].baseCurrency.symbol`) или динамические данные (использовать сеть из подключенного кошелька `const { chainId } = useActiveWeb3React()` вместо констант). Совет для использования обьекта в кажестве параметра для функции и добавление основых параметров уже в него. Возможно это избыточно для постоянного использования, но это сильно помогает если приходиться делать большие и глубокие изменения. Особенно для функций с 8+ параметрами где присутствуют опциональные =)

3. на этом этапе почти все в приложении использует динамические или переменные данные. То есть в обменнике нам достаточно изменить / добавить новый обьект с нужными полями в `networks.json` для новой сети. В основном все из этого конфига являются уже доступными в документации целевой сети. Но часть связана с тем что мы должны автоматизировать для конечных клиентов. То есть данные уникальные для каждого из них (цвета, контракты, ссылки, названия). Значит сейчас нужно создать интерфейс где пользователь сможет сам изменять и сохранять все эти данные.

3.1 В этом конфиге за это отвечает поле `"registry": "0x9664E..."`. Проще говоря Регистри это контракт для хранения всех уникальных данных, регистри у нас один на все продукты, что то типа общей бд. Так же как во время обмена мы вызываем свап контракт, приложение при загрузке будет вызывать этот контракт и загруждать все необходимые данные (<b>регистри должен быть только в сети бинанс</b>). Переходя к тому что будет видеть и делать клиент, посмотрим на то какие данные мы храним и какие из них обязательны. При загрузке обменника мы берем из конфига адрес контракта для хранения и запрашиваем настройки (для гибкости и простоты сохраняем их в строке) и парсим то что мы сохраняли (см вопрос "Q: как менять логотип или цвета?" ниже). По умолчанию там пустая строка, но в будущем мы будем использовать JSON формат. Как только мы получили все нужное, в первую очередь проверяем обязательные для работы параметры. У нас это адрес фабрики и роутера (то что нужно в обмене). У вас могут быть другие настройки. Если их нет, то не грузим основную часть, а показываем интерфейс где можно создать недостающие параметры (т.е. мастер установки, кто первый его запустит то ти будет админом). Дополнительные параметры (например логотип, пункты меню и прочие не сильно важные элементы) не должны зависеть от них, поэтому одновременно с обязательными проверяем их наличие и добавляем в приложение.
Место для создания и управления Это так называемая "админка", которую нужно сделать, где клиент будет создавать и изменять все уникальные для его проекта параметры (пример https://youtu.be/x6LJTJCVWiI ). В этом разделе мы создаем свой интерфейсадминки исходя из нашего приложения. В обменнике это разделы где клиент (админ) деплоит контракты для обмена, меняет параметры этих контрактов и часть где он меняет параметры для интерфейса

4. интерфейс админки должены сохранять данные (который ввел юзер) в тот самый контракт-хранилище из 3.1 . После деплоя контрактов (которые нужны для работы вашего приложения), мы берем их данные с новыми адресами и вызываем хранилище для их сохранения. При изменении цвета или ссылок, сохраняем их таким же образом. На перезагрузке приложение получит уже новые данные (если мы дождались подтверждение транзакций в сети). 
4.1 все инпуты админки должны быть валидированы, например если предполагается вводить erc20 адрес то дернуть контракт и убедится, что там реально ерс20. желательно это делегировать, сделать ишью на коллегу, чтоб тот заодно протестил все 

# шаг 4 пререлиз
1. добавить в dash.onout.org в раздел presale . https://github.com/noxonsu/dash.onout.org/blob/main/src/constants/index.ts#L130 (скопировать данные, самое главное id чтоб был различный от других продуктов)

2. разместить на поддомене версию с тестнет режимом, добавить в dash.onout.org ссылку на demo. Позже тестнет нужно заменить на мейннет при этом сделать, чтоб работало с токенами SWAP и USDT. т.е. наши токены в мейннете должны использоваться для демонстрации как работает продукт. 
3. записать два видео. Как пользоватся продуктом со стороны юзера (какой бенифит у юзера? не нужно растягивать как работает, сейчас цель что то опубликовать, потом уже по обратной связи доработать) и как пользоватся со стороны админа (какой бенифит у админа, как ему зарабатывать, куда воткнуть комсу?). Если админка еще не готова, то делать только то как пользуется юзер. 
4. отправить ссылку на демо и ссылку на видео в дискорд, "Hello, we published an alfa version. You can watch demo here: https:// ... . If you have any questions please use this chat. Presale is also available at https://dash.onout.org/#/presale . Current price - $1000. Next step is an admin panel development"
5. добавить https://tools.onout.org/name страницу, что бы гугл уже начал индексировать эту страницу. Гугл обычно полгода ждет, прежде чем поднять страницу в топ, поэтому чем раньше будет страничка тем лучше. На странице сделать минимальную страницу с описанием продукта по структуре: название продукта, как на этом может заработать админ, что может делать юзер, что может сделать админ (например менять логотип, название проекта, тему оформления и т.д.)


## 2. Записать видео (на английском).
Вы записываете либо своим голосом (желательно без слов паразитов и длинных пауз), либо используете любые ресурсы и инструменты для синтезирования искусственного голоса максимально приближенный к реальному, например, с использованием сервиса voicemaker.in.
### 2.1 Первое видео. Как юзер пользуется этой приложением (важно поменять логотип на наш дефолтный "your logo here")
Видео залить в [наш канал](https://www.youtube.com/channel/UCEu5-QDPFCxKm9z4BAYQSJw):
- ваш gmail аккаунт должен быть админом канала (нужно `создать новый плейлист`), 
- в описании к видео нужно добавить ссылки на все ресурсы и главное ссылку на покупку. 

Название видео: {название продукта} user interface. What user can do  

### 2.2 Второе видео. Как на своем домене зайти в админку, задеплоить контракты, как отобразить интерфейс на домене. 

```
1. открываем вкалдку: лендос, 
2. (фокус на лендос) hi all. i am onout tools developer. 
3. let me introduce a tool to create DAO  
4. произносим что это и какие особенности, выделяя некоторые части лендоса
5. let's click to "live preview" to check how it will looks like for users
6. on the main page user can "connect wallet", all EVM networks are supported
7. далее кликаем по страницам показываем, что там user can 
8. how to to manage all this stuff as admin i will show after installation
9. so, let's close the demo and click "get started"
10. you should login with your wallet and enter the email
11. select this product in the catalog, you can select WP or HTML version (или какие там будут еще)
12. pay using your wallet (показываем как происходит оплата)
13. now you can download zip file (скачиваем файл)
14. the installation process is depend on the platform you use, please follow the documentation below this video
15. if you bought static version open index.html and change this settings
16. показываем, что там за сетинги, bep20 берем с езерскана (напоминаем, что поддерживаются all EVM blockchains such as ethereum, binance smart chain, polygon and other are suported!) 
17. рассказываем про каждый сеттинг, все их включать не надо 
```

В видео указать копирайты 
```
https://tools.onout.org/lottery - get started

We are a team of blockchain developers, we build no-code tools for creating DEX, DAO, Wallet, Farming, Lottery and NFT marketplace at your own domain. View catalog https://tools.onout.org/

Ask a question! 
support@onout.org - e-mail 
https://t.me/onoutsupportbot - Telegram Bot Chat
https://support.onout.org/hc/1331700057 - Knowledge Base

Join the community! 
https://discord.gg/VwKEmHEgVN  - Join Discord
https://dash.onout.org/ - Join mailing list
https://twitter.com/onout_org - Twitter
```
Название видео: "How to create a DEX on your own domain without coding skills. Uniswap v2 fork (copy) tutorial". Названия меняем в соответствии со своим продуктом. 
Обязательно использовать как можно больше ключевых слов (см семантика п. 1)

Если админка еще не готова, то делаем админку, а этот видос записываем уже когда выходит финальный релиз.

Ссылки на видео нужно скинуть в дискорд в соотвествующий канал и опубликовать в твиттере. 
Текст "Hello, we have done 50% of development progress a {название продукта} fork. Watch videos: the user usage (link) and the admin usage (link) . This product added to "presale" tab on dash.onout.org. Presale price - $700. Estimate time for releasing is around 1 month. Cheers!"


---
## FAQ

**Q: как клиент выбирает сеть в которой будет деплоится контракты? Ему нужно подключить кошелек к приложению?**

**A:** верно, в приложении нужно отслеживать сеть из подключенного кошелька. Исходя из этого деплоить новые контракты или блокировать использование приложением, если сеть не доступна (в самом приложении, к примеру нет конфига с параметрами для этой сети)

**Q: как деплоятся контракты самого приложения, как в нем меняются переменные, например комиссия?**

**A:** для деплоя нам нужен провайдер для отправки транзакций (через **Web3js**, **Ethers**), ABI и bytecode для контракта, которые получаем после сборки исходного контракта (через **Remix**, **Truffle**, **Hardhat**) в виде JSON файла. Также нужны аргументы для конструктора в контракте, если у него они есть. Пример с **Web3**: [начало деплоя](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/utils/contract.ts#L45) и [основной метод](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/utils/contract.ts#L12). Изменение происходит за счет вызова методов контракта. Для вызова нужен адрес контракта и ABI. [Создаем экземпляр контракта](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/utils/contract.ts#L71) и можем вызывать его методы: [пример вызова](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/utils/contract.ts#L153)

**Q: как менять логотип или цвета?**

**A:** в обычном приложении мы используем параметры добавленные прямо в код. Тут нам нужно менять их динамически из интерфейса не используя базу данных и свой сервер. Если коротко, то мы выбираем блокчейн где будем сохранять данные (регистри?). Создаем простой контракт для их хранения и вызываем его методы для сохранения наших данных. В самом приложении, при загрузке, мы запрашиваем данные из контракта и добавляем их в приложение (к примеру в Redux state). Далее остальные части обновляются на новом состоянии. Пример в React приложении с обновлением логотипа: [хук для запроса данных из хранилища](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/hooks/useStorageInfo.ts#L101) -> [вызываем его в основном компоненте](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/pages/App.tsx#L109) -> [отправляем новые данные в стейт](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/pages/App.tsx#L118) -> [проверяем их и окончательно обновляем состояние](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/state/application/reducer.ts#L143) -> [в компоненте с логотипом используем данные из стейта, которые автоматически обновятся при изменениях](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/components/Header/index.tsx#L260) -> [используем нужные данные](https://github.com/noxonsu/unifactory/blob/790a17c85608b8e3e528f0e641bccd4fa9809cbd/src/components/Header/index.tsx#L267)

**Q: зачем выполняется привязка к домену, надо ли клиенту деплоить этот контракт?**

**A:** в нашем случае разработка контрактов идет на языке Solidity. Для хранение наших данных обычно используется маппинг в котором в качестве ключа служат любой валидный тип. У нас зависимость данных идет от домена, поэтому используем его (технически строку, просто в строке у нас домен). В другом сценарии / приложении в качестве ключа по которому хранятся данные может быть любой другой тип: число, адрес, строка с названием цвета и тд.
```js
// максимально простой и гибкий вариант. Хранить с любым ключем, который можно представить в виде строки.
// Сами данные тоже в виде строки, чтобы без проблем менять эти данные, без надобности в обновлении контракта.
mapping(string => string) private allData;
```
Деплоить этот контракт клиенту не нужно, это нужно сделать нам. Так как у нас должна быть какая то точка связи тех статических данных (само приложение) и динамических (цвета, названия и тд)

**Q: почему клиент должен платить (за газ) за каждое изменение интерфейса?**

**A:** все происходит через блокчейн. Соответственно все изменения требуют оплаты, так как мы постоянно изменяем состояние сети (запрос данных не требует платы). Это может быть небольшая сумма в зависимости от того как сильно меняется состояние или большая комиссия, как например при деплое контракта. Поэтому следует выбирать дешевые и быстрые сети для хранения, если функционал не требует использовать конкретную сеть. Так де мы не полагаемся на бэкенд, т.к. его взамывают, поэтом в качестве БД выбран смартконтракт. 

**Q: на каком бэкенде хранятся настройки вообще?**

**A:** все храниться в блокчейне, а конкретно в смарт контракте. Блокчейн в данном случае является "сервером", а смарт контракт "базой данных"

**Q: если клиент хочет подключить приложение к новой сети, нужно ли ему деплоить контракт для хранения настроек туда или ему надо писать нам?**

**A:** на данный момент ему нужно написать нам для того чтобы мы добавили сеть в само приложение. Далее он может использовать новую сеть, в том числе для деплоя хранилища. Есть возможность использовать только одну сеть для хранения, а остальные для главного функционала. В теории можно сделать хранение вообще всего только в одной сети и контракте. Держать в приложении только данные для этой сети и запрашивать / сохранять все данные туда же, в том числе данные для новых сетей

**Q: как вообще должна выглядить админка, какие инпуты, кнопки и функционал?**

**A:** зависит от типа данных которые нужно сохранять и от функционала. То есть практически не получиться сделать заранее то что будет использовано где-то еще. Можно сделать только компоненты под разные данные. В целом это будет что-то для простых структур в виде полей для строк (например название приложения), списка с полями для ссылок или новых елементов в меню, для цветов, для размера комиссий

**Q: как добавить новый параметр или функционал?

**A:** [пример на React с добавлением нового параметра в настройки](https://github.com/noxonsu/anyswap-crosschain/pull/4/commits/e7faf5ee11e7dc2dfe0b8209f76c30f87f11b4e3)

**Q: можно ли взять что то из старого или надо писать с нуля?**

**A:** исходя из прошлого ответа можем предположить, что сделать что-то комплексное для разных приложений не получиться. Только разные компоненты из которых мы будем составлять интерфейс. С другой стороны хорошо продуманный контракт можно сделать один раз и использовать в разных приложениях. Пример с хранилищами для разных сетей (репорт об ошибках приветствуется): [адреса в README](https://github.com/NotEternal/contracts) и [сам контракт](https://github.com/NotEternal/contracts/blob/main/contracts/Storage.sol)

**Q: с какими трудностями можно столкнутся при написании админки?**

**A:** основные моменты:
- сложность управления структурой в которой хранятся данные. Самый гибкий способ хранить строку в контракте, но тогда нам нужно самостоятельно собирать данные в эту строку, постоянно соблюдать порядок в котором нужно парсить и сохранять данные
- cоблюдение условий в местах со сложной логикой. К прмеру в [Unifactory](https://github.com/noxonsu/unifactory) для начала работы нужно задеплоить только 2 контракта на одной сети. В [Crosschain](https://github.com/noxonsu/anyswap-crosschain) же нужно деплоить множество разных контрактов с разной частотой: 1 конфиг на любой сети, по 1 роутеру на каждой сети, по 1 кросчейн токену для каждого исходного токена на каждой сети. В промежутке нужно следить чтобы мы были на нужной сети при сохранении или изменении данных
- валидация данных полностью на стороне фронта. Может быть что-то простое, к примеру проверка формата введенной строки или сложное, как при проверке правильности контракта и его методов, когда пользователь указывает EVM адрес. Один из примеров, когда без валидации приложение сломалось: в [Unifactory](https://github.com/noxonsu/unifactory) есть настройки цвета где можно ввести свой собственный в виде строки. Проверки того в каком формате строка не было. Админ вводит значение `ffffff` и сохраняет настройки в контракт. После перезагрузки пакет, который позволяет изменять формат цвета (hex в hsl, hsl в rgb и тд.), не может спарсить hex формат без **#** из-за чего мы видим только белый экран. Поэтому желательно делать валидацию на вводе данных (не сохранять не валидные) и на их получении (не применять их, если все же удалось сохранить)

**Q: как происходит авторизация админа и могут ли незнакомые люди что-то поменять? Почему это надежно?**

**A:** авторизация через EVM адрес. Если кто-то захочит что-то изменить, к примеру вызвать контракт напрямую, а не из интерфейса, то транзакции не будут валидными. Так как мы храним адрес админа в хранилище (он туда попадает при прохождении мастера установки на новом домене). При вызове контракта мы проверяем кто его вызывает и прерываем транзакцию если это не админ. Если проверки написаны правильно, то надежность данных зависит только от того, на сколько надежно админ хранит доступ к своему кошельку.

# шаг 4 релиз (мы делаем на основе данных, которые вы прислали)

1. семантика. в телеге webmasterbot > ahref ищем ключевые слова для оптимизации (how to create dex, how to fork uniswap etc..).
2. делаем лендос по структуре: шапка, видео, how to earn (for what?), amdin can, user can, описание, faq. кнопки live preview и get started. 
2.1 так же дизайнер делает превьюшки и иконки для кодканьона (80 на 80, todo: дописать размеры). Пример визуалки https://www.figma.com/file/Tm5zflJdT1vfjCwzP3RPeV/Unifactory-(Copy) 


4. заливаем в кодканьон
5. заливаем в амазон
6. делаем емейл рассылку среди нашей базы 
7. прочие дела

# сапорт и улучшения (мы совместно с вами)
1. чат сапорта + чат бот в телегу
2. поддержка по почте через тикет систему (пока нет)
3. читать комментарии на маркетплейсах

# FAQ. 
Q: Почему мне самому не сделать проудкт и залить его на маркеты? <Br>
A: Мы предлагаем грант, ревью, упаковку. кроме того насколько известно разработчики не любят общатся с клиентами (сапорт, продажи). Мы все это берем на себя. Кроме того растет база лояльных клиентов в сети onout. 
  
Q: Я программист, хочу попробовать, но не уверен. <br>
A: выберите любой доступный app (https://dappradar.com/) и попробуйте поднять копию (форк) на локалхосте. Получилось?  а теперь попробуйте поменять логотип. А теперь попробуйте урл логотипа получить из window.logoURL . Теперь попробуйте задеплоить контракты апки (ищите папку contracts в выбранном репозитории) в rinkeby. 
